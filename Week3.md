### Week3

145p ~ 207p

# 2장 테스트
- 스프링이 제공하는 중요한 가치
    1. 객체지향
    2. **테스트**

## 2.1 UserDaoTest 다시 보기
### 2.1.1 테스트의 유용성
- 만든 코드를 확신할 수 있게!
### 2.1.2 UserDaoTest의 특징
#### 웹을 통한 DAO 테스트 방법의 문제점
- DAO를 테스트하기 위해 웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 어불성설
    - 배보다 배꼽이 크다
    - 과연 DAO의 문제인지 알기 어렵다
#### 작은 단위의 테스트
- Unit test
- 빠르게 문제를 확인 가능
#### 자동수행 테스트 코드
#### 지속적인 개선과 점진적인 개발을 위한 테스트

### 2.1.3 UserDaoTest의 문제점
- 수동 확인 작업의 번거로움
  - 결과를 사람 눈으로 확인해야하는 문제
- 실행 작업의 번거로움

## 2.2 UserDaoTest 개선
### 2.2.1 테스트 검증의 자동화
- 모든 테스트는 성공과 실패
    - 성공
    - 실패
        - 진행 중 에러 발생 (테스트 에러)
        - 기대한 결과가 다름 (테스트 실패)

### 2.2.2 테스트의 효율적인 수행과 결과 관리
- JUnit의 사용

#### Junit 테스트로 전환
- 프레임워크의 기본 동작원리 : 제어의 역전
    - Junit을 사용함으로써 테스트 관련 IoC를 제공받음
#### 테스트 메소드 전환
- JUnit 프레임워크의 요구조건
    - public 메소드
    - @Test annotation
#### 검증 코드 전환
#### JUnit 테스트 실행

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit
### 2.3.1 JUnit 테스트 실행 방법
- IDE/빌드 툴을 이용한 테스트 실행

### 2.3.2 테스트 결과의 일관성
- 반복적으로 테스트를 했을 때, 테스트의 성공여부가 바뀐다면 좋은 테스트라고 할 수 없다
  - addAndGet()을 마치면 테스트 중 등록한 데이터를 삭제해서 이전 상태로 만들어주자
    - 테스트를 반복하여도 **항상 동일한 결과**를 얻을 수 있다
#### deleteAll()의 getCount() 추가
- deleteAll()
- getCount()

#### deleteAll()과 getCount()의 테스트

#### 동일한 결과를 보장하는 테스트

### 2.3.3 포괄적인 테스트
#### getCount() 테스트
#### addAndGet() 테스트 보완
#### get() 예외조건에 대한 테스트
#### 테스트를 성공시키기 위한 코드의 수정
#### 포괄적인 테스트
- 네거티브 테스트부터 만들어보자

### 2.3.4 테스트가 이끄는 개발
- 기능을 개발하고 테스트를 작성하는 것이 아닌, 테스트를 먼저 작성하고 그에 맞게 기능을 개발
#### 기능 설계를 위한 테스트
- given, when, then (?)
#### 테스트 주도 개발
- TDD, Test Driven Development

### 2.3.5 테스트 코드 개선
#### @Before
- 테스트 클래스의 인스턴스 변수 사용
  - pros and cons...?
#### 픽스처
- 테스트를 수행하는 데 필요한 정보나 오브젝트
  - 여기선 dao가 대표적인 픽스쳐

## 2.4 스프링 테스트 적용
### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리
#### 스프링 테스트 컨텍스트 프레임워크 적용
#### 테스트 메소드의 컨텍스트 공유
- 스프링의 JUnit 확장기능이 테스트 실행 전 애플리케이션 컨텍스트를 만들어두고 테스트 오브젝트의 특정 필드에 주입
  - 수행속도 ↑
#### 테스트 클래스의 컨텍스트 공유
- 앞서 하나의 테스트 클래스 내 메소드 간 컨텍스트 공유해주는 것이 전부가 아니라
- 여러 개의 테스트 클래스 간 컨텍스트 공유도 가능케 한다
  - 설정파일(ContextConfiguration)의 종류만큼 컨텍스트를 만들고, 같은 설정파일을 지정한 테스트 클래스는 이를 공유
  
#### @Autowired
- 변수에 할당 가능한 `타입`을 가진 빈을 찾는다
  - (@Qualifier )
    - 하나를 선택할 수 없으면, `이름`이 같은 빈을 찾는다
     - 이름으로도 찾지 못하면 예외 발생

### 2.4.2 DI와 테스트
- 소프트웨어 개발에서 `절대로` 바뀌지 않는 것은 없다
- 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있다
  - ex 카운팅 부가기능 등
- 테스트

#### 테스트 코드에 의한 DI
- @DirtiesContext
  - 클래스 혹은 메소드에서 애플리케이션 컨텍스트의 구성이나 상태 변경이 필요할 때
    - 다른 테스트 클래스(혹은 메소드)와 같은 애플리케이션 컨텍스트를 `공유하지 않도록`
  
#### 테스트를 위한 별도의 DI 설정
- 아예 테스트에서 사용될 빈들로 정의 된 설정파일을 만드는 것도 방법
  - test-applicationContext.xml
  
#### 컨테이너 없는 DI 테스트
- 침투적 기술과 비침투적 기술
  - 스프링의 비침투적인 특성 덕에, 컨테이너 없이도 UserDao의 테스트가 가능하다
  
#### DI를 이용한 테스트 방법 선택
- 컨테이너 없이 테스트 <- 가장 빠르고 간결
- 여러 오브젝트와 복잡한 의존관계 <- 스프링의 설정을 이용한 DI 시 편리
- 테스트 설정에 더해 예외적인 의존관계 필요 <- 테스트 코드에서 다시 수동 주입하는 방법 (@DirtiesContext)

## 2.5 학습 테스트로 배우는 스프링
- learning test
- API나 프레임워크의 기능을 테스트로 보면서 사용방법을 익혀보자

### 2.5.1 학습 테스트의 장점
- 기능 명세 + 다양한 조건
- 학습 테스트 코드를 개발 중 참고 가능
- 해당 기술 버전업 시 호환겅 검증
- 좋은 훈련
- 즐거워진다ㅎ

### 2.5.2 학습 테스트 예제
#### Junit 테스트 오브젝트 테스트
#### 스프링 테스트 컨텍스트 테스트

