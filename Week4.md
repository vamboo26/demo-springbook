### Week4

209p ~

# 3장 템플릿
- 개방 폐쇄 원칙
- `변경이 거의 일어나지 않는 코드`를 자유롭게 변경되는 부분으로부터 `독립`

## 3.1 다시 보는 초난감 DAO
### 3.1.1 예외처리 기능을 갖춘 DAO
- DB 커넥션과 같이 `제한적인 리소스`를 `공유`해 사용하는 경우, 해당 리소스의 `반환`이 보장되어야 한다
    - 이를 위해 필요한 것이 **예외처리**
    
- JDBC 수정 기능의 예외처리 코드
- JDBC 조회 기능의 예외처리 코드

## 3.2 변하는 것과 변하지 않는 것
### 3.2.1 JDBC try/catch/finally 코드의 문제점
- 코드폭탄 🔥
- 핵심은 `변하지 않으며 중복으로 많은 곳에서 쓰이는 코드 분리`

### 3.2.2 분리와 재사용을 위한 디자인 패턴 적용
#### 메소드 추출
- 변하지 않는 부분이 변하는 부분을 감싸고 있을 때 추출하기 어렵다 💩
#### 템플릿 메소드 패턴의 적용
- 상속을 통한 기능의 확장
    - 변하지 않는 부분은 슈퍼클래스, 변하는 부분은 추상 메소드로 서브 클래스
    - DAO 로직마다 새로운 클래스(서브클래스, 구현체)를 만들어야한다 💩
    - 확장 구조가 설계 시점에 고정, 컴파일 시점에 정해진 관계 -> 떨어지는 관계의 유연성 💩
#### 전략 패턴의 적용
- 오브젝트를 분리하고 **인터페이스**를 통해 의존
    - 필요에 따라 `컨텍스트`는 유지되면서 `구체적인 전략`은 바뀌는 것이 전략
    - 예제에선 구현 클래스를 직접 알고 사용한다 💩

    #### DI 적용을 위한 클라이언트/컨텍스트 분리
    - 앞선 문제 해결을 위해 고민해보자
        - 클라이언트가 컨텍스트가 필요로 하는 전략을 만들어서 제공하도록 한다
        - 





## 2.1 UserDaoTest 다시 보기
### 2.1.1 테스트의 유용성
- 만든 코드를 확신할 수 있게!
### 2.1.2 UserDaoTest의 특징
#### 웹을 통한 DAO 테스트 방법의 문제점
- DAO를 테스트하기 위해 웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 어불성설
    - 배보다 배꼽이 크다
    - 정말 DAO의 문제인지 알기 어렵다
#### 작은 단위의 테스트
-앞서 웹을 통한 방식의 '큰' 단위 테스트의 문제점을 보완하기 위해선 작은 단위의 테스트가 필요
- Unit test
    - 한 가지 관심에 집중
- 빠르게 문제를 확인 가능
#### 자동수행 테스트 코드
- 매번 테스트를 위한 사전작업을 해줘야 한다면, 번거롭고 테스트를 작성하고 싶은 마음도 사라질 것
- 자주, 빠르게, 반복할 수 있어야 유의미
#### 지속적인 개선과 점진적인 개발을 위한 테스트

### 2.1.3 UserDaoTest의 문제점
- 수동 확인 작업의 번거로움
    - 결과를 사람 눈으로 확인해야하는 문제
- 실행 작업의 번거로움

## 2.2 UserDaoTest 개선
1. 검증 자동화
2. 편리한 실행 작업
### 2.2.1 테스트 검증의 자동화
### 2.2.2 테스트의 효율적인 수행과 결과 관리
- JUnit의 사용

#### Junit 테스트로 전환
- 프레임워크의 기본 동작원리 : 제어의 역전
    - Junit을 사용함으로써 테스트 관련 IoC를 제공받음
#### 테스트 메소드 전환
- JUnit 프레임워크의 요구조건
    - public 메소드
    - @Test annotation
#### 검증 코드 전환
#### JUnit 테스트 실행

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit
### 2.3.1 JUnit 테스트 실행 방법
- IDE/빌드 툴을 이용한 테스트 실행

### 2.3.2 테스트 결과의 일관성
- 반복적으로 테스트를 했을 때, 테스트의 성공여부가 바뀐다면 좋은 테스트라고 할 수 없다
    - addAndGet()을 마치면 테스트 중 등록한 데이터를 삭제해서 이전 상태로 만들어주자
        - 테스트를 반복하여도 **항상 동일한 결과**를 얻을 수 있다
#### deleteAll()의 getCount() 추가
- deleteAll()
- getCount()

#### deleteAll()과 getCount()의 테스트

#### 동일한 결과를 보장하는 테스트

### 2.3.3 포괄적인 테스트
#### getCount() 테스트
#### addAndGet() 테스트 보완
#### get() 예외조건에 대한 테스트
#### 테스트를 성공시키기 위한 코드의 수정
#### 포괄적인 테스트
- 네거티브 테스트부터 만들어보자

### 2.3.4 테스트가 이끄는 개발
- 기능을 개발하고 테스트를 작성하는 것이 아닌, 테스트를 먼저 작성하고 그에 맞게 기능을 개발
#### 기능 설계를 위한 테스트
- given, when, then (?)
#### 테스트 주도 개발
- TDD, Test Driven Development

### 2.3.5 테스트 코드 개선
#### @Before
- per 테스트 메서드
#### 픽스처
- 테스트를 수행하는 데 필요한 정보나 오브젝트
    - 여기선 dao가 대표적인 픽스쳐

## 2.4 스프링 테스트 적용
- @BeforeClass
    - per 테스트 클래스
### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리
#### 스프링 테스트 컨텍스트 프레임워크 적용
- 테스트 실행 방법의 확장을 위한 애노테이션
    - @Runwith (junit4)
    - @ExtendWith (junit5)
#### 테스트 메소드의 컨텍스트 공유
- 스프링의 JUnit 확장기능이 테스트 실행 전 애플리케이션 컨텍스트를 만들어두고 테스트 오브젝트의 특정 필드에 주입
    - 하나의 테스트 클래스 내의 테스트 메소드는 같은 컨텍스트 공유
        - 수행속도 ↑
#### 테스트 클래스의 컨텍스트 공유
- 앞서 하나의 테스트 클래스 내 메소드 간 컨텍스트 공유해주는 것이 전부가 아니라
- 여러 개의 테스트 클래스 간 컨텍스트 공유도 가능케 한다
    - 설정파일(ContextConfiguration)의 종류만큼 컨텍스트를 만들고, 같은 설정파일을 지정한 테스트 클래스는 이를 공유
        - 수행속도 ↑

#### @Autowired
- 변수에 할당 가능한 `타입`을 가진 빈을 찾는다
    - (@Qualifier )
        - 하나를 선택할 수 없으면, `이름`이 같은 빈을 찾는다
            - 이름으로도 찾지 못하면 예외 발생

### 2.4.2 DI와 테스트
- 소프트웨어 개발에서 `절대로` 바뀌지 않는 것은 없다
- 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있다
    - ex 카운팅 부가기능 등
- 테스트

#### 테스트 코드에 의한 DI
- @DirtiesContext
    - 클래스 혹은 메소드에서 애플리케이션 컨텍스트의 구성이나 상태 변경이 필요할 때
        - 다른 테스트 클래스(혹은 메소드)와 같은 애플리케이션 컨텍스트를 `공유하지 않도록`

#### 테스트를 위한 별도의 DI 설정
- 아예 테스트에서 사용될 빈들로 정의 된 설정파일을 만드는 것도 방법
    - test-applicationContext.xml

#### 컨테이너 없는 DI 테스트
- 침투적 기술과 비침투적 기술
    - 스프링의 비침투적인 특성 덕에, 컨테이너 없이도 UserDao의 테스트가 가능하다

#### DI를 이용한 테스트 방법 선택
- 컨테이너 없이 테스트 <- 가장 빠르고 간결
- 여러 오브젝트와 복잡한 의존관계 <- 스프링의 설정을 이용한 DI 시 편리
- 테스트 설정에 더해 예외적인 의존관계 필요 <- 테스트 코드에서 다시 수동 주입하는 방법 (@DirtiesContext)

## 2.5 학습 테스트로 배우는 스프링
- learning test
- API나 프레임워크의 기능을 테스트로 보면서 사용방법을 익혀보자

### 2.5.1 학습 테스트의 장점
- 기능 명세 + 다양한 조건
- 학습 테스트 코드를 개발 중 참고 가능
- 해당 기술 버전업 시 호환겅 검증
- 좋은 훈련
- 즐거워진다ㅎ

### 2.5.2 학습 테스트 예제
#### Junit 테스트 오브젝트 테스트
#### 스프링 테스트 컨텍스트 테스트

### 2.5.3 버그 테스트
- 코드에 오류가 있을 때, 오류를 잘 드러내줄 수 있는 테스트
- 버그가 원인으로 실패하는 테스트 케이스를 작성
    - 기능을 수정 후 테스트가 성공하면 해당 버그 픽스

#### 버그 테스트의 필요성과 장점
- 테스트의 완성도 ↑
- 버그의 내용을 명확하게 분석
- 기술적인 문제 해결에 도움

```text
- 동등분할
같은 결과를 내는 값의 범위를 구분해서 대표값으로 테스트
- 경계값 분석
경계 근처의 값을 이용한 테스트
주로 0이나 타입의 최대값, 최소값 등
```

