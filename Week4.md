### Week4

209p ~ 277p

# 3장 템플릿
- 개방 폐쇄 원칙
- `변경이 거의 일어나지 않는 코드`를 자유롭게 변경되는 부분으로부터 `독립`

## 3.1 다시 보는 초난감 DAO
### 3.1.1 예외처리 기능을 갖춘 DAO
- DB 커넥션과 같이 `제한적인 리소스`를 `공유`해 사용하는 경우, 해당 리소스의 `반환`이 보장되어야 한다
    - 이를 위해 필요한 것이 **예외처리**
    
- JDBC 수정 기능의 예외처리 코드
- JDBC 조회 기능의 예외처리 코드

## 3.2 변하는 것과 변하지 않는 것
### 3.2.1 JDBC try/catch/finally 코드의 문제점
- 코드폭탄 🔥
- 핵심은 `변하지 않으며 중복으로 많은 곳에서 쓰이는 코드 분리`

### 3.2.2 분리와 재사용을 위한 디자인 패턴 적용
#### 메소드 추출
- 변하지 않는 부분이 변하는 부분을 감싸고 있을 때 추출하기 어렵다 💩
#### 템플릿 메소드 패턴의 적용
- 상속을 통한 기능의 확장
    - 변하지 않는 부분은 슈퍼클래스, 변하는 부분은 추상 메소드로 서브 클래스
    - DAO 로직마다 새로운 클래스(서브클래스, 구현체)를 만들어야한다 💩
    - 확장 구조가 설계 시점에 고정, 컴파일 시점에 정해진 관계 -> 떨어지는 관계의 유연성 💩
#### 전략 패턴의 적용
- 오브젝트를 분리하고 **인터페이스**를 통해 의존
    - 필요에 따라 `컨텍스트`는 유지되면서 `구체적인 전략`은 바뀌는 것이 전략
    - 예제에선 구현 클래스를 직접 알고 사용한다 💩

    #### DI 적용을 위한 클라이언트/컨텍스트 분리
    - 앞선 문제 해결을 위해 고민해보자
        - 클라이언트가 컨텍스트가 필요로 하는 전략을 만들어서 제공하도록 한다
        - deleteAll()은 strategy만 정해서 **주입** ⭐

## 3.3 JDBC 전략 패턴의 최적화
- 클라이언트 : `UserDao.*` 컨텍스트에 적절한 전략을 주입(메소드에 해당하는) 
- 컨텍스트 : `UserDao.jdbcContextWithStatementStrategy()` PreparedStatement를 실행하는 JDBC의 작업 흐름
- 전략 : `StatementStrategy.makePreparedStatement()` PreparedStatement의 생성

### 3.3.1 전략 클래스의 추가 정보

### 3.3.2 전략과 클라이언트의 동거
- 아직 부족하다
    - DAO 메소드마다 구현 클래스(전략)를 만들어야 한다
        - 템플릿 메소드 패턴 때 처럼 클래스가 많아진다(**차이점은 런타임 시에 다이나믹하게 DI 해준다는 점**) 💩
        - User와 같이 부가적인 정보가 있는 경우, 전략 클래스에 인스턴스 변수가 있어야 한다는 점 💩

#### 로컬 클래스
- 특정 메소드에서만 사용된다면 별도 클래스 파일을 생성하지 않고, 메소드 내부에서 로컬 클래스를 사용 가능
    - 책에는 일단 장점만 소개됐는데, 잘 쓰이지 않는 이유는 뭘까❓
#### 익명 내부 클래스

```text
중첩 클래스(nested class)
1. 독립적으로 만들어질 수 있는 static class
2. 자신이 정의된 클래스 내부에서만 만들어질 수 있는 inner class
    2-1. member inner class
    2-2. local class
    2-3. anonymous inner class
```

## 3.4 컨텍스트와 DI
- 클라이언트 : `UserDao.*` 컨텍스트에 적절한 전략을 주입(메소드에 해당하는)
- 컨텍스트 : `UserDao.jdbcContextWithStatementStrategy()` PreparedStatement를 실행하는 JDBC의 작업 흐름
- 전략 : `StatementStrategy.makePreparedStatement()`의 concrete methods, PreparedStatement의 생성
### 3.4.1 JdbcContext의 분리
#### 클래스 분리
- UserDao.jdbcContextWithStatementStrategy()를 JdbcContext.workWithStatementStrategy()로 분리
#### 빈 의존관계 변경

### 3.4.2 JdbcContext의 특별한 DI
- UserDao - JdbcContext 사이는 인터페이스를 사용하지 않고 DI를 적용
- 인터페이스를 사용하지 않았지만, JdbcContext를 스프링을 이용해 UserDao 객체에서 사용하게 주입한 것은 DI의 기본
- 왜 JdbcConext를 UserDao와 DI 구조로 만들어야할까? with Spring
    1. 가변적인 상태정보를 갖고 있지 않아 싱글톤 빈으로 적합 -> 공유
    2. JdbcContext 자체가 이미 다른 빈에 의존, JdbcContext가 관리되기 위해서라도 빈 등록이 필요
    3. 매우 긴밀하고 강력한 결합, 응집도
        - Jdbc가 아닌 JPA 등으로 변경되면 어차피 JdbcContext 자체가 변경되어야 한다
    - 이러한 이유로 인터페이스를 사용하지 않지만, 이는 마지막에 고려해봄직하다

#### 코드를 이용하는 수동 DI
- 앞서 JdbcContext를 스프링을 통한 DI 구조로 만들었는데, 이를 수동으로 관리해보자
    - 1. 싱글톤 빈 -> 그저 수백개의 오브젝트 생성을 감내
    - 2. JdbcContext가 이미 다른 빈에 의존 -> UserDao가 주입해주는 DI컨테이너 역할을 하도록 한다
- Why?
    - 굳이 인터페이스로 두지 않아도 될만큼 밀접한 두 객체를 따로 빈으로 분리하지 않고 사용
    - A.setB <- 여기서 new B(객체 생성) + B.setSomthing(다른 의존성 ex DataSource)
    - 구체적인 클래스(인터페이스를 두지 않은)와의 의존관계가 노출되지 않음 ⭐
        - 이 관계가 노출되는 것이 단점이 되는 실질적인 이유는❓

## 3.5 템플릿과 콜백
- 앞서 `전략 패턴`의 기본 구조에 `익명 내부 클래스`를 활용
    - 이를 스프링에서는 `템플릿/콜백 패턴` 이라고 부른다
        - 컨텍스트 : 템플릿
        - 전략(익명 내부 클래스) : 콜백
### 3.5.1 템플릿/콜백의 동작원리
- 템플릿 안에서 호출되는 것을 목적으로 만들어진 콜백
- 컨텍스트 안에서 사용되는 것을 목적으로 만들어진 전략(= 익명 내부 클래스)
#### 템플릿/콜백의 특징
- 메소드 레벨에서의 DI
- 콜백이 자신을 생성한 `클라이언트의 정보`를 참조한다는 것도 특징
#### JdbcContext에 적용된 템플릿/콜백
- 클라이언트(UserDao)
    1. 콜백(익명클래스(ex new StatementStrategy() {...}))을 생성  
    2. 콜백을 전달(jdbcContext.workWithStatementStrategy(callBack))  
- 템플릿  
    3. 콜백을 받아 workflow 시작 (workWithStatementStrategy로 전달된 callBack)  
    4. 참조정보 생성  
    5. 콜백에 참조정보 전달(stmt.makePreparedStatement(참조정보))  
- 콜백  
    6. 클라이언트의 변수를 참조(user)  
    7. 작업 수행 (make PreparedStatement ps) 후 템플릿에 결과 전달  
- 템플릿  
    8. 다시 작업 수행 및 클라이언트에 결과 전달  

### 3.5.2 편리한 콜백의 재사용
- 익명 클래스가 보기에 좋지 않을 수 있다 💩

#### 콜백의 분리와 재활용
#### 콜백과 템플릿의 결합

### 3.5.3 템플릿/콜백의 응용
- 스프링의 기본이 되는 `전략 패턴` `DI` `템플릿/콜백 패턴`에 익숙해져야 이해하고 응용, 확장 할 수 있다
- 고정된 작업 흐름과 중복이 보이면
    - 코드 분리를 고려
        - 일부 작업을 필요에 따라 바꾸어야 하면 인터페이스를 두고 전략패턴을 적용하고 DI로 의존관계를 관리
            - 바뀌는 부분이 동시에 여러 종류라면 템플릿/콜백 패턴을 고려

#### 테스트와 try/catch/finally
#### 중복의 제거와 템플릿/콜백 설계
- 앞서 만든 Cal* 에 변경이 생긴다면? 기능이 추가된다면?
    - 템플릿/콜백을 생각해보자
    - 변하는 부분과 변하지 않는 부분을 구분
        - 템플릿과 콜백을 구분
            - 각각이 무엇을 전달해야할까

#### 템플릿/콜백의 재설계
#### 제네릭스를 이용한 콜백 인터페이스

## 3.6 스프링의 JdbcTemplate
- JdbcContext 대신 JdbcTemplate를 사용해보자
### 3.6.1 update()
### 3.6.2 queryForInt()
### 3.6.3 queryForObject()
### 3.6.4 query()
#### 기능 정의와 테스트 작성
#### query() 템플릿을 이용하는 getAll() 구현
#### 테스트 보완
### 3.6.5 재사용 가능한 콜백의 분리
#### DI를 위한 코드 정리
#### 중복 제거
#### 템플릿/콜백 패턴과 UserDao

## 3.7 정리
`sayonara`
