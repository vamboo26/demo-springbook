### Week7 2021-02-13

401 ~ 475p

# 6장 AOP
- AOP, 그중에서도 **선언적 트랜잭션 기능**을 활용해 학습해본다

## 6.1 트랜잭션 코드의 분리
- UserService 는 앞서 `서비스 추상화`를 통해 데이터 접근 기술에 구애받지 않는 코드로 만들었지만,  
트랜잭션 경계설정을 위한 코드가 남아있다 💩
### 6.1.1 메소드 분리
- `UserService.upgradeLevels()`를 보면 중간에 비즈니스 로직이 있고 위아래로 트랜잭션 경계설정하는 코드가 존재
    - 비즈니스 로직 코드를 분리해본다
### 6.1.2 DI를 이용한 클래스의 분리
#### DI 적용을 이용한 트랜잭션 분리
- UserService 구현 클래스를 직접 사용하는 구조를 탈피하자
  - UserSerivce 인퍼테이스를 구현한 UserServiceImpl
  - UserSerivce 인터페이스를 구현한 UserSerivceTx
#### UserService 인터페이스 도입
#### 분리된 트랜잭션 기능
#### 트랜잭션 적용을 위한 DI 설정
1. UserServiceImpl.upgradeLevels() 에서 트랜잭션 경계설정 코드를 삭제
2. UserServiceTx.upgradeLevels() 에서 트랜잭션 경계설정의 역할을 수행하며,  
실제 upgradeLevels() 로직은 DI로 주입받은 userService 에서 수행한다.
3. 이제 클라이언트는 UserServiceImpl을 주입받은 UserServiceTx를 사용한다.
#### 트랜잭션 분리에 따른 테스트 수정
#### 트랜잭션 경계설정 코드 분리의 장점
- 비즈니스 로직을 담당하는 구현클래스와 트랜잭션을 담당하는 클래스가 분리

## 6.2 고립된 단위 테스트
- 작은 테스트는 실패의 원인을 찾기가 쉽다
### 6.2.1 복잡한 의존관계 속의 테스트
### 6.2.2 테스트 대상 오브젝트 고립시키기
#### 테스트를 위한 UserServiceImpl 고립
#### 고립된 단위 테스트 활용
#### UserDao 목 오브젝트
#### 테스트 수행 성능의 향상
### 6.2.3 단위 테스트와 통합 테스트
### 6.2.4 목 프레임워크
#### Mockito 프레임워크

## 6.3 다이내믹 프록시와 팩토리 빈
### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴
#### 데코레이터 패턴
#### 프록시 패턴
### 6.3.2 다이내믹 프록시
#### 프록시의 구성과 프록시 작성의 문제점
#### 리플렉션
#### 프록시 클래스
#### 다이내믹 프록시 적용
#### 다이내믹 프록시의 확장
### 6.3.3 다이내믹 프록시를 이용한 트랜잭션 부가기능
#### 트랜잭션 InvocationHandler
### TransactionHandler 와 다이내믹 프록시를 이용하는 테스트
### 6.3.4 다이내믹 프록시를 위한 팩토리 빈
#### 팩토리 빈
#### 팩토리 빈의 설정 방법
#### 다이내믹 프록시를 만들어주는 팩토리 빈
#### 트랜잭션 프록시 팩토리 빈
#### 트랜잭션 프록시 팩토리 빈 테스트
### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계
#### 프록시 팩토리 빈의 재사용
#### 프록시 팩토리 빈 방식의 장점
#### 프록시 팩토리 빈의 한계

## 6.4 스프링의 프록시 팩토리 빈
### 6.4.1 ProxyFactoryBean
#### 어드바이스: 타깃이 필요 없는 순수한 부가기능
#### 포인트컷: 부가기능 적용 대상 메소드 선정 방법
### 6.4.2 ProxyFactoryBean 적용
#### TransactionAdvice
#### 스프링 XML 설정파일
#### 테스트
#### 어드바이스와 포인트컷의 재사용
