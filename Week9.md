### Week9 2021-03-21

# 7장 스프링 핵심 기술의 응용

## 7.1 SQL과 DAO의 분리
- SQL을 DAO 코드에서 적절히 분리하면 어떨까?
  - 빈번한 SQL의 변경
  - 매번 소스를 컴파일하는건 번거롭고 위험

### 7.1.1 XML 설정을 이용한 분리
- bean 설정 xml 파일에 sql 문장을 정의하여 주입
  - `userDao` - `sqlAdd`

### 7.1.2 SQL 제공 서비스
- bean 설정 xml 파일에 sql 문장을 정의하여 주입
  - `userDao` - `sqlService`
  - `sqlService` - `sqlMap`

## 7.2 인터페이스의 분리와 자기참조 빈
### 7.2.4 변화를 위한 준비: 인터페이스 분리
#### 책임에 따른 인터페이스 정의
- `SqlService`의 역할 분리
  - SQL 정보를 외부 리소스로부터 읽어온다 - `SqlReader`
  - SQL을 보관해두었다가 필요할 때 제공 - `SqlRegistry`
  
### 7.2.5 자기참조 빈으로 시작하기
#### 다중 인터페이스 구현과 간접 참조
- 기존 `XmlSqlService`는 사실 인터페이스로 명세가 정의되어있지 않았을 뿐이지 `SqlReader`, `SqlRegistry`, `SqlService` 모두 구현한 클래스나 다름없다
#### 인터페이스를 이용한 분리
#### 자기참조 빈 설정

### 7.2.6 디폴트 의존관계
#### 확장 가능한 기반 클래스
#### 디폴트 의존관계를 갖는 빈 만들기
- DI 설정이 없을 경우 디폴트로 적용하고 싶은 의존 오브젝트를 주입

## 7.3 서비스 추상화 적용
#### 멤버 클래스를 참조하는 통합 클래스
- 의존 오브젝트를 사용하되 스태틱 멤버 클래스로 내장하고 자신만 사용
  - 유연성은 손해 보더라도 내부적으로 낮은 결합도를 유지한 채로 응집도 높은 구현 가능
  - 구조적으로는 강하게 결합되어 있지만 논리적으로 명확하게 분리되는 구조

### 7.3.3 리소스 추상화
#### 리소스 로더
- `ResourceLoader`가 처리하는 접두어
  - `file:`
  - `classpath:`
  - `없음`
    - 구현체에 따라 위치가 정해진다
  - `http:`

## 7.4 인터페이스 상속을 통한 안전한 기능확장
- 애플리케이션을 새로 시작하지 않고 특정 메모리에 담아 사용하는 SQL을 변경하고 싶다면?

### 7.4.1 DI와 기능의 확장
#### DI를 의식하는 설계
- 책임에 따라 오브젝트 분리
- 의존 오브젝트는 언제나 자유롭게 확장될 수 있다

#### DI와 인터페이스 프로그래밍
- 인터페이스 사용
  - 다형성
  - 클라이언트 - 의존 오브젝트 사이의 관계를 명확하게 한다
    - 사용하는 인터페이스의 기능 명세에 따라 클라이언트가 어떤 기능을 의존 오브젝트에 의존하는 지 알 수 있다
    - 역으로 보면 클라이언트의 성격, 정체성을 보여주기도 함
- 인터페이스 분리 원칙

### 7.4.2 인터페이스 상속
- 조회 기능이 있는 SqlRegistry, 수정 기능을 확장한 UpdatableSqlRegistry
  - UpdatableSqlRegistry를 구현한 A 클래스가 있어도, 클라이언트가 A에 의존할 때 어떤 인터페이스 타입으로 의존하는 지에 따라 다르다

## 7.5 DI를 이용해 다양한 구현 방법 적용하기
- 인터페이스 분리 원칙 실제 구현
- 실시간 변경 작업 시 고려해야 할 첫 번째 : 동시성

### 7.5.1 ConcurrentHashMap을 이용한 수정 가능 SQL 레지스트리
- 멀티스레드 환경에서 HashMap을 조작하려면, Collections.synchronizedMap() 등을 이용해 외부에서 동기화 필요
  - 요청이 많은 서비스에서 성능 문제
- ConcurrentHashMap은 데이터 조작 시 전체 데이터에 대해 락을 걸지 않고 조회는 락을 아예 사용하지 않는다
  - 어느 정도 안전하면서 성능이 보장되는 동기화된 HashMap
    
#### 수정 가능 SQL 레지스트리 테스트
#### 수정 가능 SQL 레지스트리 구현

### 7.5.2 내장형 데이터베이스를 이용한 SQL 레지스트리 만들기
- Derby, HSQL, H2
- 애플리케이션 내에서 DB를 기동하고 초기화

#### 내장형 DB 빌더 학습 테스트
#### 내장형 DB를 이용한 SqlRegistry 만들기
- `EmbeddedDatabaseBuilder`는 빈으로 등록 후 초기화 코드가 필요
  - 초기화 코드가 필요하다면 팩토리 빈으로 만드는 것이 좋다 ❓

#### UpdatableSqlRegistry 테스트 코드의 재사용
#### XML 설정을 통한 내장형 DB의 생성과 적용

### 7.5.3 트랜잭션 적용
#### 다중 SQL 수정에 대한 트랜잭션 테스트
- `EmbeddedDbSqlRegistry`에 트랜잭션 기능 추가
#### 코드를 이용한 트랜잭션 적용

## 7.6 스프링 3.1의 DI
#### 자바 언어의 변화와 스프링
- 애노테이션의 메타정보 활용
- 정책과 관례를 이용한 프로그래밍

### 7.6.1 자바 코드를 이용한 빈 설정
#### 테스트 컨텍스트의 변경
#### <context:annotation-config \> 제거
#### \<bean>의 전환
#### 전용 태그 전환

### 7.6.2 빈 스캐닝과 자동 와이어링
#### @Autowired를 이용한 자동와이어링
#### @Component를 이용한 자동 빈 등록

### 7.6.3 컨텍스트 분리와 @Import
#### 테스트용 컨텍스트 분리
#### @Import

### 7.6.4 프로파일
#### @Profile과 @ActiveProfiles
#### 컨테이너의 빈 등록 정보 확인
#### 중첩 클래스를 이용한 프로파일 적용

### 7.6.5 프로퍼티 소스
#### @PropertySource
#### PropertySourcesPlaceholderConfigurer

### 7.6.6 빈 설정의 재사용과 @Enable*
#### 빈 설정자
#### @Enable* 애노테이션



